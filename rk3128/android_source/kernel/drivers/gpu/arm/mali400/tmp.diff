commit 69ccbee87d2456d5ab6636f92a6cc017a01ee070
Author: chenzhen <chenzhen@rock-chips.com>
Date:   Mon Sep 7 16:31:04 2015 +0800

    rk312x, mali_400_driver, platform_dependent_part :
    1.	tidy source code, add notes.
    2.	make it more 'difficult' to dump down in mali_dvfs_list,
    	enhancing performance when running 3D games.

diff --git a/drivers/gpu/arm/mali400/mali/platform/rk30/arm_core_scaling.c b/drivers/gpu/arm/mali400/mali/platform/rk30/arm_core_scaling.c
index 6c50e89..93b9772 100755
--- a/drivers/gpu/arm/mali400/mali/platform/rk30/arm_core_scaling.c
+++ b/drivers/gpu/arm/mali400/mali/platform/rk30/arm_core_scaling.c
@@ -13,6 +13,9 @@
  * Example core scaling policy.
  */
 
+// #define ENABLE_DEBUG_LOG
+#include "custom_log.h"
+
 #include "arm_core_scaling.h"
 
 #include <linux/mali/mali_utgard.h>
@@ -23,6 +26,16 @@
 static int num_cores_total;
 static int num_cores_enabled;
 
+/**
+ * ¶ÔÁ¬ĞøµÄ request_to_disable_on_core µÄ¼ÆÊı.
+ */
+static int count_of_requests_to_disable_one_core = 0;
+/**
+ * ÔÚ count_of_requests_to_disable_one_core µÈÓÚ±¾ value µÄÊ±ºò,
+ * ½«Ö´ĞĞÈ·ÊµµÄ disable_one_core ²Ù×÷.
+ */
+#define NUM_OF_REQUESTS_TO_REALLY_DISABLE_ONE_CORE		(10)
+
 static struct work_struct wq_work;
 
 static void set_num_cores(struct work_struct *work)
@@ -46,7 +59,7 @@ static void enable_one_core(void)
 
 static void disable_one_core(void)
 {
-	if (1 < num_cores_enabled) {
+	if (1 < num_cores_enabled) {		// num_cores_enabled ±ØĞë´óÓÚµÈÓÚ 1.
 		--num_cores_enabled;
 		schedule_work(&wq_work);
 		MALI_DEBUG_PRINT(3, ("Core scaling: Disabling one core\n"));
@@ -92,31 +105,63 @@ void mali_core_scaling_term(void)
 void mali_core_scaling_update(struct mali_gpu_utilization_data *data)
 {
 	/*
-	 * This function implements a very trivial PP core scaling algorithm.
+	 * This function 
+	 * implements a very trivial PP core scaling algorithm.
 	 *
 	 * It is _NOT_ of production quality.
-	 * The only intention behind this algorithm is to exercise and test the
-	 * core scaling functionality of the driver.
-	 * It is _NOT_ tuned for neither power saving nor performance!
+	 * The only intention 
+	 *	behind this algorithm 
+	 * is to exercise and test the
+	 * core scaling functionality 
+	 *	of the driver.
+	 * It is _NOT_ tuned 
+	 *	for neither power saving 
+	 *	nor performance!
 	 *
-	 * Other metrics than PP utilization need to be considered as well
+	 * Other metrics 
+	 *	than PP utilization 
+	 * need to be considered as well
 	 * in order to make a good core scaling algorithm.
 	 */
 
 	MALI_DEBUG_PRINT(3, ("Utilization: (%3d, %3d, %3d), cores enabled: %d/%d\n", data->utilization_gpu, data->utilization_gp, data->utilization_pp, num_cores_enabled, num_cores_total));
 
-	/* NOTE: this function is normally called directly from the utilization callback which is in
-	 * timer context. */
+	/* NOTE: 
+	 * this function 
+	 * is normally called directly 
+	 *	from the utilization callback 
+	 *		which is in timer context. */
 
-	if (PERCENT_OF(90, 256) < data->utilization_pp) {
+	if (PERCENT_OF(90, 256) < data->utilization_pp) 
+	{
+		V("to enable max num of pp_cores.");
 		enable_max_num_cores();
-	} else if (PERCENT_OF(50, 256) < data->utilization_pp) {
+		count_of_requests_to_disable_one_core = 0;
+	} 
+	else if (PERCENT_OF(50, 256) < data->utilization_pp) 
+	{
+		V("to enable more one pp_core.");
 		enable_one_core();
-	} else if (PERCENT_OF(40, 256) < data->utilization_pp) {
+		count_of_requests_to_disable_one_core = 0;
+	} 
+	else if (PERCENT_OF(40, 256) < data->utilization_pp) 
+	{
 		/* do nothing */
-	} else if (PERCENT_OF(0, 256) < data->utilization_pp) {
-		disable_one_core();
-	} else {
+		count_of_requests_to_disable_one_core = 0;
+	}
+	else if (PERCENT_OF(0, 256) < data->utilization_pp) 
+	{
+		count_of_requests_to_disable_one_core++;
+		if ( count_of_requests_to_disable_one_core >= NUM_OF_REQUESTS_TO_REALLY_DISABLE_ONE_CORE )
+		{
+			V("to disable a pp_core.");
+			disable_one_core();
+			count_of_requests_to_disable_one_core = 0;
+		}
+	} 
+	else 
+	{
 		/* do nothing */
+		count_of_requests_to_disable_one_core = 0;
 	}
 }
diff --git a/drivers/gpu/arm/mali400/mali/platform/rk30/arm_core_scaling.h b/drivers/gpu/arm/mali400/mali/platform/rk30/arm_core_scaling.h
index d4a11f3..556c406 100755
--- a/drivers/gpu/arm/mali400/mali/platform/rk30/arm_core_scaling.h
+++ b/drivers/gpu/arm/mali400/mali/platform/rk30/arm_core_scaling.h
@@ -20,10 +20,14 @@ struct mali_gpu_utilization_data;
 
 /**
  * Initialize core scaling policy.
+ * .DP : core_scaling_policy, core_scaling_facility.
  *
- * @note The core scaling policy will assume that all PP cores are on initially.
+ * @note 
+ * The core scaling policy will assume 
+ *      that all PP cores are on initially.
  *
- * @param num_pp_cores Total number of PP cores.
+ * @param num_pp_cores 
+ *      Total number of PP cores.
  */
 void mali_core_scaling_init(int num_pp_cores);
 
@@ -33,9 +37,11 @@ void mali_core_scaling_init(int num_pp_cores);
 void mali_core_scaling_term(void);
 
 /**
- * Update core scaling policy with new utilization data.
+ * Update core scaling policy 
+ *      with new utilization data.
  *
- * @param data Utilization data.
+ * @param data 
+ *      Utilization data.
  */
 void mali_core_scaling_update(struct mali_gpu_utilization_data *data);
 
diff --git a/drivers/gpu/arm/mali400/mali/platform/rk30/custom_log.h b/drivers/gpu/arm/mali400/mali/platform/rk30/custom_log.h
index 3e3de1b..8cd6bd3 100755
--- a/drivers/gpu/arm/mali400/mali/platform/rk30/custom_log.h
+++ b/drivers/gpu/arm/mali400/mali/platform/rk30/custom_log.h
@@ -44,7 +44,7 @@ extern "C" {
  */
     
 /** ÈôÏÂÁĞ macro ÓĞ±»¶¨Òå, ²Å Ê¹ÄÜ log Êä³ö. */
-#define ENABLE_DEBUG_LOG
+// #define ENABLE_DEBUG_LOG
 
 /** .! : ÈôĞèÒªÈ«¾ÖµØ¹Ø±Õ D log, ¿ÉÒÔÊ¹ÄÜÏÂÃæµÄ´úÂë. */
 /*
diff --git a/drivers/gpu/arm/mali400/mali/platform/rk30/mali_dvfs.c b/drivers/gpu/arm/mali400/mali/platform/rk30/mali_dvfs.c
index 0402e6d..da84abc 100755
--- a/drivers/gpu/arm/mali400/mali/platform/rk30/mali_dvfs.c
+++ b/drivers/gpu/arm/mali400/mali/platform/rk30/mali_dvfs.c
@@ -6,9 +6,26 @@
  * published by the Free Software FoundatIon.
  */
 
+
+// #define ENABLE_DEBUG_LOG
+#include "custom_log.h"
+
 #include "mali_platform.h"
 #include "mali_dvfs.h"
 
+/*---------------------------------------------------------------------------*/
+
+/**
+ * è‹¥ count_of_continuous_requests_to_jump_up_in_dvfs_level_table è¾¾åˆ° value, 
+ * å°†è§¦å‘ä¸€æ¬¡ current_dvfs_level jump_up.
+ */
+#define	NUM_OF_CONTINUOUS_REQUESTS_TO_TRIGGER_REAL_JUMPING_UP		(1)
+/**
+ * è‹¥ count_of_continuous_requests_to_jump_down_in_dvfs_level_table è¾¾åˆ° value, 
+ * å°†è§¦å‘ä¸€æ¬¡ current_dvfs_level jump_down.
+ */
+#define NUM_OF_CONTINUOUS_REQUESTS_TO_TRIGGER_REAL_JUMPING_DOWN		(30)
+
 #define level0_min 0
 #define level0_max 70
 #define levelf_max 100
@@ -19,30 +36,114 @@
 #define work_to_dvfs(w) container_of(w, struct mali_dvfs, work)
 #define dvfs_to_drv_data(dvfs) container_of(dvfs, struct mali_platform_drv_data, dvfs)
 
+/*---------------------------------------------------------------------------*/
+
+/**
+ * .KP : 
+ * work_to_handle_mali_utilization_event çš„å®ç°ä¸»ä½“, 
+ * å°†æ ¹æ® current_mali_utilization_data, æ”¹å˜ current_dvfs_level.
+ */
 static void mali_dvfs_event_proc(struct work_struct *w)
 {
-	struct mali_dvfs *dvfs = work_to_dvfs(w);
+	struct mali_dvfs *dvfs = work_to_dvfs(w);	// mali_dvfs_context.
 	struct mali_platform_drv_data *drv_data = dvfs_to_drv_data(dvfs);
 	unsigned int utilisation = dvfs->utilisation;
-	unsigned int level = dvfs->current_level;
-	const struct mali_fv_info *threshold = &drv_data->fv_info[level];
+	unsigned int level = dvfs->current_level;	// index_of_current_dvfs_level.
+	const struct mali_fv_info *threshold = &drv_data->fv_info[level];	//  current_dvfs_level.
 	int ret;
 
-	utilisation = utilisation * 100 / 256;
+	utilisation = utilisation * 100 / 256;	// utilization_in_percentage
 
 	// dev_dbg(drv_data->dev, "utilisation percent = %d\n", utilisation);
-
-	if (utilisation > threshold->max &&
-	    level < drv_data->fv_info_length - 1 )
-		level += 1;
-	else if (level > 0 && utilisation < threshold->min)
-		level -= 1;
+	V("mali_utilization_in_percentage : %d; index_of_current_level : %d; min: %d, max : %d",
+		utilisation,
+		level,
+		threshold->min,
+		threshold->max);
+	V("num_of_requests_to_jump_up : %d; num_of_requests_to_jump_down : %d",
+		dvfs->m_count_of_continuous_requests_to_jump_up,
+		dvfs->m_count_of_continuous_requests_to_jump_down);
+		
+
+	if ( utilisation > threshold->max )
+	{
+		dvfs->m_count_of_continuous_requests_to_jump_down = 0;
+
+		/* è‹¥ current_dvfs_level è¿˜ "æœ‰" ä¸Šè·³çš„ç©ºé—´, åˆ™... */
+		if ( level < (drv_data->fv_info_length - 1) )
+		{
+			V("to count one request_to_jump_up.");
+			dvfs->m_count_of_continuous_requests_to_jump_up++;
+			
+			/* è‹¥è¶³å¤Ÿè§¦å‘ä¸€æ¬¡ real_jump_up, åˆ™... */
+			if ( dvfs->m_count_of_continuous_requests_to_jump_up 
+				>= NUM_OF_CONTINUOUS_REQUESTS_TO_TRIGGER_REAL_JUMPING_UP )
+			{
+				V("to preset real_jump_up.");
+				level += 1;
+
+				dvfs->m_count_of_continuous_requests_to_jump_up = 0;
+
+				goto MAKE_DVFS_LEVEL_UPDATE_EFFECTIVE;
+			}
+			/* å¦åˆ™, å³è¿˜ "ä¸" è¶³ä»¥ real_jump_up, åˆ™... */
+			else
+			{
+				return;
+			}
+		}
+		/* å¦åˆ™, å³ "æ²¡æœ‰" ä¸Šè·³çš„ç©ºé—´äº†, åˆ™... */
+		else
+		{
+			return;
+		}
+	}
+	else if ( utilisation < (threshold->min) )
+	{
+		dvfs->m_count_of_continuous_requests_to_jump_up = 0;
+
+		/* è‹¥ current_dvfs_level è¿˜æœ‰ ä¸‹è·³çš„ç©ºé—´, åˆ™... */
+		if ( level > 0 )
+		{
+			V("to count one request_to_jump_down.");
+			dvfs->m_count_of_continuous_requests_to_jump_down++;
+
+			/* è‹¥è¶³å¤Ÿè§¦å‘ä¸€æ¬¡ real_jump_down, åˆ™... */
+			if ( dvfs->m_count_of_continuous_requests_to_jump_down
+				>= NUM_OF_CONTINUOUS_REQUESTS_TO_TRIGGER_REAL_JUMPING_DOWN )
+			{
+				V("to preset real_jump_down.");
+				level -= 1;
+
+				dvfs->m_count_of_continuous_requests_to_jump_down = 0;
+				
+				goto MAKE_DVFS_LEVEL_UPDATE_EFFECTIVE;
+			}
+			else
+			{
+				return;
+			}
+		}
+		/* å¦åˆ™, å³ "æ²¡æœ‰" ä¸‹è·³çš„ç©ºé—´äº†, åˆ™... */
+		else
+		{
+			return;
+		}
+	}
+	/* å¦åˆ™, å³ mali_utilization åœ¨ 'min' å’Œ 'max' ä¹‹é—´, å³ current_dvfs_level åˆé€‚, åˆ™ ... */
 	else
+	{
+		dvfs->m_count_of_continuous_requests_to_jump_up = 0;
+		dvfs->m_count_of_continuous_requests_to_jump_down = 0;
 		return;
+	}
 
+#if 0
 	dev_dbg(drv_data->dev, "Setting dvfs level %u: freq = %lu Hz\n",
 		level, drv_data->fv_info[level].freq);
+#endif
 
+MAKE_DVFS_LEVEL_UPDATE_EFFECTIVE:
 	ret = mali_set_level(drv_data->dev, level);
 	if (ret) {
 		dev_err(drv_data->dev, "set freq error, %d", ret);
@@ -50,6 +151,9 @@ static void mali_dvfs_event_proc(struct work_struct *w)
 	}
 }
 
+/**
+ * è¿”å› mali_dvfs_facility å½“å‰æ˜¯å¦è¢«ä½¿èƒ½.
+ */
 bool mali_dvfs_is_enabled(struct device *dev)
 {
 	struct mali_platform_drv_data *drv_data = dev_get_drvdata(dev);
@@ -58,6 +162,9 @@ bool mali_dvfs_is_enabled(struct device *dev)
 	return dvfs->enabled;
 }
 
+/**
+ * ä½¿èƒ½ mali_dvfs_facility.
+ */
 void mali_dvfs_enable(struct device *dev)
 {
 	struct mali_platform_drv_data *drv_data = dev_get_drvdata(dev);
@@ -66,6 +173,9 @@ void mali_dvfs_enable(struct device *dev)
 	dvfs->enabled = true;
 }
 
+/**
+ * ç¦ç”¨ mali_dvfs_facility.
+ */
 void mali_dvfs_disable(struct device *dev)
 {
 	struct mali_platform_drv_data *drv_data = dev_get_drvdata(dev);
@@ -73,8 +183,17 @@ void mali_dvfs_disable(struct device *dev)
 
 	dvfs->enabled = false;
 	cancel_work_sync(&dvfs->work);
+	
+	/* ä½¿ç”¨ lowest_dvfs_level. */
+	if ( 0 != mali_set_level(dev, 0) ) 
+	{
+		W("fail to set current_dvfs_level to index 0.");
+	}
 }
 
+/**
+ * è¿”å›å½“å‰ mali_dvfs_context ä¸­æœ€åè®°å½•çš„ mali_utilization.
+ */
 unsigned int mali_dvfs_utilisation(struct device *dev)
 {
 	struct mali_platform_drv_data *drv_data = dev_get_drvdata(dev);
@@ -83,18 +202,27 @@ unsigned int mali_dvfs_utilisation(struct device *dev)
 	return dvfs->utilisation;
 }
 
+/**
+ * æ ¹æ®å½“å‰çš„ mali_utilization_event, å¯¹åº”è°ƒæ•´ mali_dvfs_facility.
+ * è¿è¡Œåœ¨ context_of_common_part_calling_back_mali_utilization_event ä¸­.
+ */
 int mali_dvfs_event(struct device *dev, u32 utilisation)
 {
 	struct mali_platform_drv_data *drv_data = dev_get_drvdata(dev);
 	struct mali_dvfs *dvfs = &drv_data->dvfs;
 
 	dvfs->utilisation = utilisation;
+	V("mali_utilization_in_percentage : %d", utilisation * 100 / 256);	// .CP : 
 
 	if (dvfs->enabled)
+	{
+		/* å°† work_to_handle_mali_utilization_event æ”¾ç½®åˆ° kernel_global_workqueue, å¾…æ‰§è¡Œ. */
 		schedule_work(&dvfs->work);
+	}
 
 	return MALI_TRUE;
 }
+
 static void mali_dvfs_threshold(u32 div, struct mali_platform_drv_data *drv_data)
 {
 	int length = drv_data->fv_info_length;
@@ -130,11 +258,13 @@ static void mali_dvfs_threshold(u32 div, struct mali_platform_drv_data *drv_data
 	}
 }
 
+/*---------------------------------------------------------------------------*/
+
 int mali_dvfs_init(struct device *dev)
 {
 	struct mali_platform_drv_data *drv_data = dev_get_drvdata(dev);
-	struct mali_dvfs *dvfs = &drv_data->dvfs;
-	struct cpufreq_frequency_table *freq_table;
+	struct mali_dvfs *dvfs = &drv_data->dvfs;	// mali_dvfs_context.
+	struct cpufreq_frequency_table *freq_table;	// gpu_clk_freq_table.
 	int i = 0;
 	int div_dvfs;
 	int ret;
@@ -145,6 +275,7 @@ int mali_dvfs_init(struct device *dev)
 		return -1;
 	}
 
+	/* ç¡®å®š len_of_avaialble_dvfs_level_list. */
 	while (freq_table[i].frequency != CPUFREQ_TABLE_END) {
 		drv_data->fv_info_length++;
 		i++;
@@ -176,6 +307,9 @@ int mali_dvfs_init(struct device *dev)
 
 	INIT_WORK(&dvfs->work, mali_dvfs_event_proc);
 	dvfs->enabled = true;
+	
+	dvfs->m_count_of_continuous_requests_to_jump_up = 0;
+	dvfs->m_count_of_continuous_requests_to_jump_down = 0;
 
 	return 0;
 }
@@ -185,6 +319,10 @@ void mali_dvfs_term(struct device *dev)
 	struct mali_platform_drv_data *drv_data = dev_get_drvdata(dev);
 	struct mali_dvfs *dvfs = &drv_data->dvfs;
 
+	dvfs->m_count_of_continuous_requests_to_jump_up = 0;
+	dvfs->m_count_of_continuous_requests_to_jump_down = 0;
+
 	dvfs->enabled = false;
 	cancel_work_sync(&dvfs->work);
 }
+
diff --git a/drivers/gpu/arm/mali400/mali/platform/rk30/mali_dvfs.h b/drivers/gpu/arm/mali400/mali/platform/rk30/mali_dvfs.h
index d204b85..977ab8e 100755
--- a/drivers/gpu/arm/mali400/mali/platform/rk30/mali_dvfs.h
+++ b/drivers/gpu/arm/mali400/mali/platform/rk30/mali_dvfs.h
@@ -12,19 +12,58 @@
 #ifndef _MALI_DVFS_H_
 #define _MALI_DVFS_H_
 
+
+/**
+ * mali_dvfs_context_t, 
+ * context of mali_dvfs_facility.
+ */
 struct mali_dvfs {
+	/**
+	 * work_to_handle_mali_utilization_event.
+	 */
 	struct work_struct work;
+	/**
+	 * current_mali_utilization.
+	 */
 	unsigned int utilisation;
+	/**
+	 * index_of_current_dvfs_level.
+	 * current_dvfs_level åœ¨ available_dvfs_level_list ä¸­çš„ index.
+	 */
 	unsigned int current_level;
+
+	/**
+	 * mali_dvfs_facility æ˜¯å¦è¢«ä½¿èƒ½.
+	 */
 	bool enabled;
+	
+	/**
+	 * count_of_continuous_requests_to_jump_up_in_dvfs_level_table.
+	 * å¯¹ "è¿ç»­" çš„ requests_to_jump_up_in_dvfs_level_table è®¡æ•°.
+	 */
+	unsigned int m_count_of_continuous_requests_to_jump_up;
+
+	/**
+	 * count_of_continuous_requests_to_jump_down_in_dvfs_level_table.
+	 * å¯¹ "è¿ç»­" çš„ requests_to_jump_down_in_dvfs_level_table è®¡æ•°.
+	 */
+	unsigned int m_count_of_continuous_requests_to_jump_down;
 };
 
 int mali_dvfs_init(struct device *dev);
+
 void mali_dvfs_term(struct device *dev);
-void mali_set_dvfs(struct device *dev, bool enable);
+
+// void mali_set_dvfs(struct device *dev, bool enable);
+
 bool mali_dvfs_is_enabled(struct device *dev);
+
 void mali_dvfs_enable(struct device *dev);
+
 void mali_dvfs_disable(struct device *dev);
+
 unsigned int mali_dvfs_utilisation(struct device *dev);
+
 int mali_dvfs_event(struct device *dev, u32 utilisation);
+
 #endif		/*_MALI_DVFS_H_*/
diff --git a/drivers/gpu/arm/mali400/mali/platform/rk30/mali_platform.c b/drivers/gpu/arm/mali400/mali/platform/rk30/mali_platform.c
index 121487d..884a3ad 100755
--- a/drivers/gpu/arm/mali400/mali/platform/rk30/mali_platform.c
+++ b/drivers/gpu/arm/mali400/mali/platform/rk30/mali_platform.c
@@ -10,8 +10,13 @@
 
 /**
  * @file mali_platform.c
- * Platform specific Mali driver functions for a default platform
+ * Platform specific Mali driver functions 
+ *      for a default platform
  */
+
+// #define ENABLE_DEBUG_LOG
+#include "custom_log.h"
+
 #include <linux/workqueue.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
@@ -31,18 +36,36 @@
 #include "mali_platform.h"
 
 
+/**
+ * æ˜¯å¦ä½¿èƒ½ core_scaling æœºåˆ¶.
+ * .DP : core_scaling : æ ¹æ®å½“å‰ mali_utilization_data, é…ç½® mali_gpu ä¸­å…·ä½“ä½¿ç”¨çš„ pp_core çš„ä¸ªæ•°.
+ */
 static int mali_core_scaling_enable;
 
 u32 mali_group_error;
 
-struct device *mali_dev;
+/**
+ * anchor_of_device_of_mali_gpu.
+ */
+static struct device *mali_dev;
 
+/**
+ * è®¾ç½® current_dvfs_level.
+ *
+ * @param level
+ *	å¾…è®¾ç½®ä¸º current çš„ dvfs_level å®ä¾‹, åœ¨ dvfs_level_list ä¸­çš„ index, 
+ *	å³ index_of_new_current_level.
+ *
+ * @return
+ *	0, æˆåŠŸ.
+ *	å…¶ä»– value, å¤±è´¥.
+ */
 int mali_set_level(struct device *dev, int level)
 {
 	struct mali_platform_drv_data *drv_data = dev_get_drvdata(dev);
-	unsigned long freq;
+	unsigned long freq;				// cpu_clk_freq_of_new_current_level.
 	int ret;
-	unsigned int current_level;
+	unsigned int current_level;			// index_of_old_current_level.
 
 	_mali_osk_mutex_wait(drv_data->clockSetlock);
 
@@ -50,18 +73,24 @@ int mali_set_level(struct device *dev, int level)
 	freq = drv_data->fv_info[level].freq;
 
 	if (level == current_level) {
+		D("we are already in the target level, to exit.");
 		_mali_osk_mutex_signal(drv_data->clockSetlock);
 		return 0;
 	}
 
+	/* .KP : è°ƒç”¨ dvfs_module çš„æ¥å£, å°† cpu_clk è®¾ç½®ä¸º 'freq'. */
 	ret = dvfs_clk_set_rate(drv_data->clk, freq);
 	if (ret) {
 		_mali_osk_mutex_signal(drv_data->clockSetlock);
 		return ret;
 	}
 
-	dev_dbg(dev, "set freq %lu\n", freq);
-
+	// dev_dbg(dev, "set freq %lu of dvfs_level %d, \n", freq, level);
+	D("have set gpu_clk to freq %lu of new_dvfs_level %d, the old_level is %d.",
+		freq,
+		level,
+		current_level);
+	/* update index_of_current_dvfs_level. */
 	drv_data->dvfs.current_level = level;
 
 	_mali_osk_mutex_signal(drv_data->clockSetlock);
@@ -69,6 +98,9 @@ int mali_set_level(struct device *dev, int level)
 	return 0;
 }
 
+/**
+ * åˆå§‹åŒ– gpu_dvfs_node å’Œ gpu_power_domain.
+ */
 static int mali_clock_init(struct device *dev)
 {
 	int ret;
@@ -115,6 +147,8 @@ static void mali_clock_term(struct device *dev)
 	drv_data->power_state = false;
 }
 
+/*---------------------------------------------------------------------------*/
+
 static ssize_t show_available_frequencies(struct device *dev,
 					  struct device_attribute *attr,
 					  char *buf)
@@ -222,6 +256,9 @@ static const struct attribute_group mali_attr_group = {
 	.attrs	= mali_sysfs_entries,
 };
 
+/**
+ * åˆ›å»º sysfs_nodes_of_platform_dependent_part.
+ */
 static int mali_create_sysfs(struct device *dev)
 {
 	int ret;
@@ -233,15 +270,21 @@ static int mali_create_sysfs(struct device *dev)
 	return ret;
 }
 
-void mali_remove_sysfs(struct device *dev)
+static void mali_remove_sysfs(struct device *dev)	// æœªè¢«å¼•ç”¨.
 {
 	sysfs_remove_group(&dev->kobj, &mali_attr_group);
 }
 
+/*---------------------------------------------------------------------------*/
+
+/**
+ * å¯¹ platform_device_of_mali_gpu,
+ * å®Œæˆ ä»…å’Œ platform_dependent_part æœ‰å…³(å’Œ common_part æ— å…³) çš„åˆå§‹åŒ–.
+ */
 _mali_osk_errcode_t mali_platform_init(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
-	struct mali_platform_drv_data *mali_drv_data;
+	struct mali_platform_drv_data *mali_drv_data;	// mali_driver_private_data.
 	int ret;
 
 	mali_drv_data = devm_kzalloc(dev, sizeof(*mali_drv_data), GFP_KERNEL);
@@ -270,6 +313,7 @@ _mali_osk_errcode_t mali_platform_init(struct platform_device *pdev)
 
 	mali_drv_data->clockSetlock = _mali_osk_mutex_init(_MALI_OSK_LOCKFLAG_ORDERED,
 				_MALI_OSK_LOCK_ORDER_UTILIZATION);
+
 	mali_core_scaling_enable = 1;
 
    	return 0;
@@ -283,6 +327,8 @@ _mali_osk_errcode_t mali_platform_deinit(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct mali_platform_drv_data *drv_data = dev_get_drvdata(dev);
+	
+	mali_remove_sysfs(dev);
 
 	mali_core_scaling_term();
 	mali_clock_term(dev);
@@ -291,20 +337,41 @@ _mali_osk_errcode_t mali_platform_deinit(struct platform_device *pdev)
 	return 0;
 }
 
-_mali_osk_errcode_t mali_power_domain_control(u32 bpower_off)
+/*---------------------------------------------------------------------------*/
+
+/**
+ * å¯¹ (mali_power_domain) gpu_power_domain (ä¸Šç”µ, å¼€ clk) / (ä¸‹ç”µ, å…³ clk).
+ * @param bpower_off
+ *      0, å¯¹ gpu_power_domain ä¸Šç”µ.
+ *      1, ä¸‹ç”µ.
+ */
+static _mali_osk_errcode_t mali_power_domain_control(u32 bpower_off)
 {
 	struct mali_platform_drv_data *drv_data = dev_get_drvdata(mali_dev);
 
-	if (bpower_off == 0) {
-		if (!drv_data->power_state) {
+	// D_DEC(bpower_off);
+
+	/* è‹¥è¦ä¸Šç”µ, åˆ™ ... */
+	if (bpower_off == 0)
+	{
+		if (!drv_data->power_state) 
+		{
+			D("to ENABLE clk to gpu_dvfs_node and power UP gpu_power_domain.");
 			dvfs_clk_prepare_enable(drv_data->clk);
 			clk_prepare_enable(drv_data->pd);
+
 			drv_data->power_state = true;
 		}
-	} else if (bpower_off == 1) {
-		if (drv_data->power_state) {
+	} 
+	/* å¦åˆ™, è‹¥è¦ä¸‹ç”µ, åˆ™ ... */
+	else if (bpower_off == 1) 
+	{
+		if (drv_data->power_state) 
+		{
+			D("to DISABLE clk to gpu_dvfs_node and power DOWN gpu_power_domain.");
 			dvfs_clk_disable_unprepare(drv_data->clk);
 			clk_disable_unprepare(drv_data->pd);
+
 			drv_data->power_state = false;
 		}
 	}
@@ -314,35 +381,59 @@ _mali_osk_errcode_t mali_power_domain_control(u32 bpower_off)
 
 _mali_osk_errcode_t mali_platform_power_mode_change(mali_power_mode power_mode)
 {
-	switch(power_mode) {
+	u32 bpower_off = 0;		// ä¸Šç”µ.
+
+	switch(power_mode) 
+	{
 		case MALI_POWER_MODE_ON:
 			MALI_DEBUG_PRINT(2, ("MALI_POWER_MODE_ON\r\n"));
-			mali_power_domain_control(MALI_POWER_MODE_ON);
+			mali_dvfs_enable(mali_dev);
+			bpower_off = 0;
 			break;
+
 		case MALI_POWER_MODE_LIGHT_SLEEP:
 			MALI_DEBUG_PRINT(2, ("MALI_POWER_MODE_LIGHT_SLEEP\r\n"));
-			mali_power_domain_control(MALI_POWER_MODE_LIGHT_SLEEP);
+			mali_dvfs_disable(mali_dev);
+			/* é¢„ç½®å°†ä¸‹ç”µ. */
+			bpower_off = 1;
 			break;
+
 		case MALI_POWER_MODE_DEEP_SLEEP:
 			MALI_DEBUG_PRINT(2, ("MALI_POWER_MODE_DEEP_SLEEP\r\n"));
-			mali_power_domain_control(MALI_POWER_MODE_DEEP_SLEEP);
+			mali_dvfs_disable(mali_dev);
+			/* é¢„ç½®å°†ä¸‹ç”µ. */
+			bpower_off = 1;
 			break;
+
 		default:
 			MALI_DEBUG_PRINT(2, ("mali_platform_power_mode_change:power_mode(%d) not support \r\n",
 					 power_mode));
+			return _MALI_OSK_ERR_INVALID_ARGS;
 	}
-	
-    return 0;
+
+	mali_power_domain_control(bpower_off);
+
+	return 0;
 }
+
+/*---------------------------------------------------------------------------*/
+
+/**
+ * å°†æ³¨å†Œåˆ° common_part ä¸­çš„, å¯¹ mali_utilization_event çš„ handler,
+ * å³ common_part ä¼šç›´æ¥å°† mali_utilization_event é€šçŸ¥å›è°ƒåˆ°æœ¬å‡½æ•°.
+ */
 void mali_gpu_utilization_handler(struct mali_gpu_utilization_data *data)
 {
 	if(data->utilization_pp > 256)
 		return;
 
 	if (mali_core_scaling_enable)
+	{
 		mali_core_scaling_update(data);
+	}
 
 	// dev_dbg(mali_dev, "utilization:%d\r\n", data->utilization_pp);
 
 	mali_dvfs_event(mali_dev, data->utilization_pp);
 }
+
diff --git a/drivers/gpu/arm/mali400/mali/platform/rk30/mali_platform.h b/drivers/gpu/arm/mali400/mali/platform/rk30/mali_platform.h
index a493d70..6222847 100755
--- a/drivers/gpu/arm/mali400/mali/platform/rk30/mali_platform.h
+++ b/drivers/gpu/arm/mali400/mali/platform/rk30/mali_platform.h
@@ -10,7 +10,7 @@
 
 /**
  * @file mali_platform.h
- * Platform specific Mali driver functions
+ * Platform specific Mali driver functions.
  */
 
 #ifndef __MALI_PLATFORM_H__
@@ -26,7 +26,9 @@
 extern "C" {
 #endif
 
-/** @brief description of power change reasons
+/** 
+ * @brief 
+ * description of power change reasons
  */
 typedef enum mali_power_mode_tag
 {
@@ -35,20 +37,82 @@ typedef enum mali_power_mode_tag
 	MALI_POWER_MODE_DEEP_SLEEP,   /**< Mali has been idle for a long time, or OS suspend */
 } mali_power_mode;
 
+/**
+ * dvfs_level_t, æ ‡è¯†ä¸€ä¸ª dvfs_level (çš„å…·ä½“é…ç½®).
+ * .DP : dvfs_level.
+ */
 struct mali_fv_info {
+	/**
+	 * å½“å‰ dvfs_level ä½¿ç”¨çš„ gpu_clk_freq.
+	 */
 	unsigned long freq;
+	/**
+	 * .DP : min_mali_utilization_in_percentage_in_this_level.
+	 * è‹¥å½“å‰çš„ mali_utilization_in_percentage 
+	 *	å°äº min_mali_utilization_in_percentage_in_this_level,
+	 *		åˆ™è§¦å‘ä¸€æ¬¡ requests_to_jump_down_in_dvfs_level_table, 
+	 * å½“ å¯¹ requests_to_jump_down_in_dvfs_level_table çš„è¿ç»­è®¡æ•° 
+	 * (.DP : continuous_count_of_requests_to_jump_down) è¾¾åˆ°ä¸€å®šæ•°å€¼, 
+	 *	åˆ™ dvfs_facility ä¼šä¸‹è·³ä¸€ä¸ª level.
+	 */
 	unsigned int min;
+	/**
+	 * .DP : max_mali_utilization_in_percentage_in_this_level.
+	 * è‹¥å½“å‰çš„ mali_utilization_in_percentage 
+	 * 	å¤§äº max_mali_utilization_in_percentage_in_this_level,
+	 *		åˆ™è§¦å‘ä¸€æ¬¡ requests_to_jump_up_in_dvfs_level_table, 
+	 * å½“ å¯¹ requests_to_jump_up_in_dvfs_level_table çš„è¿ç»­è®¡æ•° 
+	 * (.DP : continuous_count_of_requests_to_jump_up) è¾¾åˆ°ä¸€å®šæ•°å€¼, 
+	 *	åˆ™ dvfs_facility ä¼šä¸Šè·³ä¸€ä¸ª level.
+	 */
 	unsigned int max;
 };
 
+/**
+ * mali_driver_private_data_t.
+ * å’Œ å¹³å°ç›¸å…³çš„ mali_driver çš„ç§æœ‰æ•°æ®,
+ *		åŒ…å« clk, power_domain handles, mali_dvfs_facility ç­‰.
+ *
+ * è¯¥ç±»å‹åœ¨ platform_dependent_part ä¸­å®šä¹‰, æ˜¾ç„¶ä¹Ÿåªä¼šåœ¨ platform_dependent_part ä¸­ä½¿ç”¨.
+ */
 struct mali_platform_drv_data {
+
+	/** 
+	 * gpu_dvfs_node
+	 */
 	struct dvfs_node *clk;
+
+	/** 
+	 * gpu_power_domain. 
+	 */
 	struct clk *pd;
+
+	/**
+	 * available_dvfs_level_list.
+	 * å°†ç”¨äºä¿å­˜ ç³»ç»Ÿé…ç½®æ”¯æŒçš„æ‰€æœ‰ dvfs_level.
+	 * .R : å®é™…ä¸Š, æ”¾åœ¨ mali_dvfs_context ä¸­ä¸ºå®œ.
+	 */
 	struct mali_fv_info *fv_info;
+	/**
+	 * len_of_available_dvfs_level_list, ä¹Ÿå³ æ ¹æ®ç³»ç»Ÿé…ç½®å¾—åˆ°çš„ available_dvfs_level çš„ä¸ªæ•°.
+	 */
 	unsigned int fv_info_length;
+
+	/**
+	 * mali_dvfs_context.
+	 */
 	struct mali_dvfs dvfs;
+
+	/**
+	 * device_of_mali_gpu.
+	 */
 	struct device *dev;
+
+	/**
+	 * gpu æ˜¯å¦ "è¢«ä¸Šç”µ, ä¸”è¢«é€å…¥ clk".
+	 */
 	bool power_state;	
+
 	_mali_osk_mutex_t *clockSetlock;
 };
 
@@ -78,14 +142,23 @@ _mali_osk_errcode_t mali_platform_deinit(struct platform_device *pdev);
 _mali_osk_errcode_t mali_platform_power_mode_change(mali_power_mode power_mode);
 
 
-/** @brief Platform specific handling of GPU utilization data
+/** 
+ * @brief 
+ * Platform specific handling 
+ *      of GPU utilization data
  *
- * When GPU utilization data is enabled, this function will be
- * periodically called.
+ * When GPU utilization data is enabled,
+ * this function 
+ * will be periodically called.
  *
- * @param utilization The workload utilization of the Mali GPU. 0 = no utilization, 256 = full utilization.
+ * @param utilization 
+ *      The workload utilization 
+ *              of the Mali GPU.
+ *      0 = no utilization,
+ *      256 = full utilization.
  */
 void mali_gpu_utilization_handler(struct mali_gpu_utilization_data *data);
+
 int mali_set_level(struct device *dev, int level);
 
 #ifdef __cplusplus
diff --git a/drivers/gpu/arm/mali400/mali/platform/rk30/rk3066.c b/drivers/gpu/arm/mali400/mali/platform/rk30/rk3066.c
index 7581721..6fc7b87 100755
--- a/drivers/gpu/arm/mali400/mali/platform/rk30/rk3066.c
+++ b/drivers/gpu/arm/mali400/mali/platform/rk30/rk3066.c
@@ -8,6 +8,22 @@
  * by a licensing agreement from ARM Limited.
  */
  
+
+/**
+ * @file rk3066.c
+ * å®ç° rk30_platform ä¸­çš„ platform_specific_strategy_callbacks,
+ * å®é™…ä¸Šä¹Ÿæ˜¯ platform_dependent_part çš„é¡¶å±‚.
+ * 
+ * mali_device_driver(mdd) åŒ…å«ä¸¤éƒ¨åˆ† : 
+ *	.DP : platform_dependent_part : 
+ *		ä¾èµ– platform éƒ¨åˆ†,
+ *		æºç åœ¨ <mdd_src_dir>/mali/platform/<platform_name> ç›®å½•ä¸‹.
+ *	.DP : common_parts : ARM å®ç°çš„é€šç”¨çš„éƒ¨åˆ†.
+ */
+
+// #define ENABLE_DEBUG_LOG
+#include "custom_log.h"
+
 #include <linux/platform_device.h>
 #include <linux/version.h>
 #include <linux/pm.h>
@@ -28,6 +44,7 @@ static int mali_runtime_suspend(struct device *device)
 {
 	int ret = 0;
 	MALI_DEBUG_PRINT(4, ("mali_runtime_suspend() called\n"));
+	D("enter.");
 
 	if (NULL != device->driver &&
 	    NULL != device->driver->pm &&
@@ -45,6 +62,7 @@ static int mali_runtime_resume(struct device *device)
 {
 	int ret = 0;
 	MALI_DEBUG_PRINT(4, ("mali_runtime_resume() called\n"));
+	D("enter.");
 
 	mali_platform_power_mode_change(MALI_POWER_MODE_ON);
 
@@ -62,6 +80,7 @@ static int mali_runtime_idle(struct device *device)
 {
 	int ret = 0;
 	MALI_DEBUG_PRINT(4, ("mali_runtime_idle() called\n"));
+	D("enter.");
 
 	if (NULL != device->driver &&
 	    NULL != device->driver->pm &&
@@ -83,6 +102,7 @@ static int mali_os_suspend(struct device *device)
 	int ret = 0;
 
 	MALI_DEBUG_PRINT(4, ("mali_os_suspend() called\n"));
+	D("enter.");
 	
 	if (NULL != device->driver &&
 	    NULL != device->driver->pm &&
@@ -101,6 +121,7 @@ static int mali_os_resume(struct device *device)
 	int ret = 0;
 
 	MALI_DEBUG_PRINT(4, ("mali_os_resume() called\n"));
+	D("enter.");
 
 	mali_platform_power_mode_change(MALI_POWER_MODE_ON);
 
@@ -119,6 +140,7 @@ static int mali_os_freeze(struct device *device)
 	int ret = 0;
 
 	MALI_DEBUG_PRINT(4, ("mali_os_freeze() called\n"));
+	D("enter.");
 
 	if (NULL != device->driver &&
 	    NULL != device->driver->pm &&
@@ -135,6 +157,7 @@ static int mali_os_thaw(struct device *device)
 	int ret = 0;
 
 	MALI_DEBUG_PRINT(4, ("mali_os_thaw() called\n"));
+	D("enter.");
 
 	if (NULL != device->driver &&
 	    NULL != device->driver->pm &&
@@ -164,6 +187,13 @@ static struct device_type mali_gpu_device_device_type =
 	.pm = &mali_gpu_device_type_pm_ops,
 };
 
+/**
+ * platform_specific_data_of_platform_device_of_mali_gpu.
+ *
+ * ç±»å‹ 'struct mali_gpu_device_data' ç”± common_part å®šä¹‰,
+ * å®ä¾‹ä¹Ÿå°†è¢« common_part å¼•ç”¨, 
+ * æ¯”å¦‚é€šçŸ¥ mali_utilization_event ç­‰.
+ */
 static struct mali_gpu_device_data mali_gpu_data =
 {
 	.shared_mem_size = 1024* 1024 * 1024, /* 1GB */
@@ -183,10 +213,19 @@ static void mali_platform_device_add_config(struct platform_device *pdev)
 	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
 }
 
+/*---------------------------------------------------------------------------*/
+
+/**
+ * å°†è¢« common_part å›è°ƒçš„, å¯¹ platform_device_of_mali_gpu åˆå§‹åŒ–çš„ç­–ç•¥å›è°ƒå®ç°.
+ *
+ * .DP : platform_specific_strategy_callbacks_called_by_common_part, 
+ *       platform_specific_strategy_callbacks : 
+ *              è¢« common_part è°ƒç”¨çš„ å¹³å°ç›¸å…³çš„ç­–ç•¥å›è°ƒ.
+ */
 int mali_platform_device_init(struct platform_device *pdev)
 {
 	int err = 0;
-	int num_pp_cores = 0;
+	int num_pp_cores = 0;               // num_of_pp_cores.
 	MALI_DEBUG_PRINT(2,("mali_platform_device_register() called\n"));
 
 	if (cpu_is_rk312x())
@@ -198,9 +237,12 @@ int mali_platform_device_init(struct platform_device *pdev)
 
 	mali_platform_device_add_config(pdev);
 
+	/* å°† platform_specific_data æ·»åŠ åˆ° platform_device_of_mali_gpu. 
+	 * è¿™é‡Œçš„ platform_specific_data çš„ç±»å‹ç”± common_part å®šä¹‰. */
 	err = platform_device_add_data(pdev, &mali_gpu_data,
 				       sizeof(mali_gpu_data));
 	if (err == 0) {
+		/* .KP : åˆå§‹åŒ– platform_device_of_mali_gpu ä¸­ä»…å’Œ platform_dependent_part ç›¸å…³çš„éƒ¨åˆ†. */
 		err = mali_platform_init(pdev);
 		if (err == 0) {
 
@@ -220,9 +262,13 @@ int mali_platform_device_init(struct platform_device *pdev)
 	return err;
 }
 
+/**
+ * å°†è¢« common_part å›è°ƒçš„, å¯¹ platform_device_of_mali_gpu ç»ˆæ­¢åŒ–çš„ç­–ç•¥å›è°ƒå®ç°.
+ */
 void mali_platform_device_deinit(struct platform_device *pdev)
 {
 	MALI_DEBUG_PRINT(4, ("mali_platform_device_unregister() called\n"));
 
 	mali_platform_deinit(pdev);
 }
+
